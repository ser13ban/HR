# RBAC Refactoring Plan - .NET Best Practices Implementation

## Brief Description

Refactor the current scattered Role-Based Access Control (RBAC) implementation to follow .NET best practices by centralizing authorization logic using ASP.NET Core's built-in authorization framework. The current implementation has authorization checks scattered across services and controllers, making it difficult to maintain and test. This refactor will create a centralized, reusable, and easily testable authorization system.

## Current Issues Analysis

The existing RBAC implementation has several problems:
- Authorization logic is scattered across multiple services (`FeedbackService.CanUserViewFeedbackAsync`, `AbsenceService.IsEmployeeManagerAsync`, `EmployeeService.DetermineIfLimitedView`)
- Controllers manually extract user IDs from claims repeatedly (`GetCurrentUserId()`, `GetCurrentEmployeeId()`)
- Authorization checks are mixed with business logic in services
- No centralized policy definitions
- Difficult to unit test authorization logic
- Inconsistent authorization patterns across different controllers

## Technical Implementation Plan

### Phase 1: Authorization Infrastructure Setup

#### 1.1 Create Authorization Requirements and Handlers
**Files to create:**
- `HrAPI/Authorization/Requirements/CanViewEmployeeProfileRequirement.cs`
- `HrAPI/Authorization/Requirements/CanEditEmployeeProfileRequirement.cs`
- `HrAPI/Authorization/Requirements/CanViewFeedbackRequirement.cs`
- `HrAPI/Authorization/Requirements/CanGiveFeedbackRequirement.cs`
- `HrAPI/Authorization/Requirements/CanManageAbsenceRequestsRequirement.cs`
- `HrAPI/Authorization/Handlers/CanViewEmployeeProfileHandler.cs`
- `HrAPI/Authorization/Handlers/CanEditEmployeeProfileHandler.cs`
- `HrAPI/Authorization/Handlers/CanViewFeedbackHandler.cs`
- `HrAPI/Authorization/Handlers/CanGiveFeedbackHandler.cs`
- `HrAPI/Authorization/Handlers/CanManageAbsenceRequestsHandler.cs`

#### 1.2 Create Authorization Policies
**Files to create:**
- `HrAPI/Authorization/Policies/AuthorizationPolicies.cs` - Static class defining all policy names
- `HrAPI/Extensions/AuthorizationServiceExtensions.cs` - Extension method to register policies

#### 1.3 Create User Context Service
**Files to create:**
- `HrAPI/Services/IUserContextService.cs`
- `HrAPI/Services/UserContextService.cs`

This service will encapsulate user identity extraction and provide a clean interface for getting current user information.

### Phase 2: Controller Refactoring

#### 2.1 Update Controllers to Use Authorization Attributes
**Files to modify:**
- `HrAPI/Controllers/EmployeeController.cs`
- `HrAPI/Controllers/FeedbackController.cs`
- `HrAPI/Controllers/AbsenceController.cs`

Changes:
- Remove manual user ID extraction methods (`GetCurrentUserId`, `GetCurrentEmployeeId`)
- Replace with `IUserContextService` injection
- Add policy-based `[Authorize]` attributes to action methods
- Remove authorization logic from controller actions

#### 2.2 Create Base Controller
**Files to create:**
- `HrAPI/Controllers/BaseController.cs`

Provides common functionality and user context access for all controllers.

### Phase 3: Service Layer Cleanup

#### 3.1 Remove Authorization Logic from Services
**Files to modify:**
- `HrAPI/Services/FeedbackService.cs`
- `HrAPI/Services/AbsenceService.cs`
- `HrAPI/Services/EmployeeService.cs`
- `HrAPI/Services/IFeedbackService.cs`
- `HrAPI/Services/IAbsenceService.cs`
- `HrAPI/Services/IEmployeeService.cs`

Changes:
- Remove `CanUserViewFeedbackAsync`, `CanUserGiveFeedbackAsync` methods from `FeedbackService`
- Remove `IsEmployeeManagerAsync` method from `AbsenceService`
- Remove `DetermineIfLimitedView` logic from `EmployeeService`
- Simplify service method signatures by removing `requestingUserId` parameters where authorization is now handled at controller level
- Focus services purely on business logic

### Phase 4: Authorization Policy Configuration

#### 4.1 Update Program.cs
**Files to modify:**
- `HrAPI/Program.cs`

Changes:
- Register authorization handlers in DI container
- Configure authorization policies using the new requirements
- Register `IUserContextService`

#### 4.2 Create Authorization Constants
**Files to create:**
- `HrAPI/Authorization/Constants/Policies.cs`
- `HrAPI/Authorization/Constants/Roles.cs`

Centralize all policy names and role constants to avoid magic strings.

### Phase 5: Enhanced Authorization Features

#### 5.1 Resource-Based Authorization
**Files to create:**
- `HrAPI/Authorization/Requirements/ResourceOperationRequirement.cs`
- `HrAPI/Authorization/Handlers/EmployeeResourceHandler.cs`
- `HrAPI/Authorization/Handlers/FeedbackResourceHandler.cs`
- `HrAPI/Authorization/Handlers/AbsenceRequestResourceHandler.cs`

For scenarios where authorization depends on the specific resource being accessed (e.g., viewing a specific employee's profile).

#### 5.2 Custom Authorization Attributes
**Files to create:**
- `HrAPI/Authorization/Attributes/RequireManagerRoleAttribute.cs`
- `HrAPI/Authorization/Attributes/RequireOwnershipOrManagerAttribute.cs`

Custom authorization attributes for common scenarios to reduce boilerplate.

## Algorithm Details

### Authorization Flow
1. **Request arrives** at controller action
2. **Authorization middleware** checks if user is authenticated
3. **Policy evaluation** runs through registered authorization handlers
4. **Handlers evaluate requirements** using user claims and resource context
5. **Authorization result** determines if request proceeds or returns 403 Forbidden
6. **Controller action executes** with clean separation from authorization logic
7. **Service layer** focuses purely on business logic without authorization checks

### User Context Resolution
1. Extract user ID from `ClaimTypes.NameIdentifier`
2. Cache user information during request lifetime
3. Provide typed access to user role and permissions
4. Handle edge cases (missing claims, invalid user ID format)

### Policy Evaluation Strategy
- **Role-based policies**: Check user role against required roles
- **Resource-based policies**: Evaluate user's relationship to specific resources
- **Composite policies**: Combine multiple requirements (e.g., manager OR resource owner)
- **Hierarchical permissions**: Manager role inherits employee permissions

## Implementation Benefits

1. **Centralized Authorization**: All authorization logic in dedicated handlers
2. **Testability**: Authorization handlers can be unit tested independently
3. **Reusability**: Policies can be applied to multiple controllers/actions
4. **Maintainability**: Changes to authorization rules in one place
5. **Performance**: Built-in caching of authorization results
6. **Consistency**: Uniform authorization patterns across the application
7. **Extensibility**: Easy to add new roles and permissions
8. **Separation of Concerns**: Services focus on business logic, not authorization

## Migration Strategy

1. **Phase 1**: Create new authorization infrastructure alongside existing code
2. **Phase 2**: Update one controller at a time to use new system
3. **Phase 3**: Clean up services after all controllers are migrated
4. **Phase 4**: Remove old authorization methods and update tests
5. **Phase 5**: Add enhanced features and optimizations

This approach ensures zero downtime and allows for gradual migration with rollback capability at each phase.
